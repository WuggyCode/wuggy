<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>wuggy.plugins.baselanguageplugin API documentation</title>
<meta name="description" content="BaseLanguagePlugin is the Base class used for all official Wuggy language plugins and custom local language plugins ‚Ä¶" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>wuggy.plugins.baselanguageplugin</code></h1>
</header>
<section id="section-intro">
<p>BaseLanguagePlugin is the Base class used for all official Wuggy language plugins and custom local language plugins.</p>
<h1 id="examples">Examples</h1>
<h2 id="creating-a-custom-language-plugin">Creating a custom language plugin</h2>
<h3 id="based-on-an-official-language-plugin">Based on an official language plugin</h3>
<p>In this example, we will start off creating a custom language plugin. Create an empty Python file called <code>your_project_file.py</code> and try to run the following code within this file:</p>
<pre><code class="language-python">from wuggy.generators.wuggygenerator import WuggyGenerator

g = WuggyGenerator()
g.load(&quot;orthographic_english&quot;)
for w in g.generate_classic([&quot;wuggy&quot;]):
    print(w)
</code></pre>
<p>Uh oh! You should be getting an error that <code><a title="wuggy" href="../index.html">wuggy</a></code> is not a word in the <code>orthographic_english</code> lexicon. Let's assume <code><a title="wuggy" href="../index.html">wuggy</a></code> is an important slang word which is essential for our research. We need to customize the <code>orthographic_english</code> lexicon and add the word <code><a title="wuggy" href="../index.html">wuggy</a></code>. </p>
<ol>
<li>To keep things simple, let's redownload the <code>orthographic_english</code> plugin to our local machine in the folder your project is currently in. First, create a new folder in the same directory as the Python file you just tested the script in. Call it <code>modified_orthographic_english</code>. Visit the <a href="https://github.com/Zenulous/wuggy_language_plugin_data">official Wuggy language data repository</a> and download the plugin from here and save both the <code>.py</code> and <code>.txt</code> files in the root of the <code>modified_orthographic_english</code> folder. Your project folder structure should now look like this:</li>
</ol>
<pre><code>your_project_file.py
üìÅmodified_orthographic_english
    -- orthographic_english.py
    -- orthographic_english.txt
</code></pre>
<ol>
<li>
<p>The <code>orthographic_english.py</code> file needs to be modified slightly to accomodate for the different folder structure, since the plugin is used outside of the official plugin folder. Go into this file and replace the line <code>from &hellip;baselanguageplugin import <a title="wuggy.plugins.baselanguageplugin.BaseLanguagePlugin" href="#wuggy.plugins.baselanguageplugin.BaseLanguagePlugin">BaseLanguagePlugin</a></code> with <code>from <a title="wuggy.plugins.baselanguageplugin" href="#wuggy.plugins.baselanguageplugin">wuggy.plugins.baselanguageplugin</a> import <a title="wuggy.plugins.baselanguageplugin.BaseLanguagePlugin" href="#wuggy.plugins.baselanguageplugin.BaseLanguagePlugin">BaseLanguagePlugin</a></code>.</p>
</li>
<li>
<p>Now we are getting somewhere: you already have a functional local language plugin which you can import. Let's ensure that you have followed the steps properly. Replace the contents of <code>your_project_file.py</code> with:</p>
</li>
</ol>
<pre><code class="language-python">from wuggy.generators.wuggygenerator import WuggyGenerator

from my_custom_plugin.orthographic_english import LanguagePlugin

g = WuggyGenerator()
g.load(&quot;modified_orthographic_english&quot;, LanguagePlugin())
for w in g.generate_classic([&quot;wuggy&quot;]):
    print(w)
</code></pre>
<p>This code passes a custom language plugin name to wuggy, together with an instance of the imported LanguagePlugin class defined in <code>orthographic_english.py</code>. Note how when you run this code, the language plugin loads, but of course you still receive an error since <code><a title="wuggy" href="../index.html">wuggy</a></code> is not a valid word in the lexicon.</p>
<ol>
<li>To modify the language lexicon, browse into <code>orthographic_english.txt</code>. Each word is written in the format <code>WORD{tab}WORD_IN_SYLLABLES{tab}OCCURRENCE_PER_MILLION_WORDS</code> (the three word elements are split using a single tab: you must adhere to this for each line in the lexicon). To add <code><a title="wuggy" href="../index.html">wuggy</a></code> to the lexicon, paste <code>wuggy
wug-gy
0.01</code> at the end of the document (we assume that wuggy occurs 0.01 times per million words).</li>
</ol>
<p>Now, when you execute <code>orthographic_english.py</code> again, you should be generating pseudowords for the word <code><a title="wuggy" href="../index.html">wuggy</a></code>!</p>
<h3 id="from-scratch">From scratch</h3>
<p>TODO: a new example will be here soon.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;.. include:: ../../documentation/baselanguageplugin/baselanguageplugin.md&#34;&#34;&#34;
from collections import namedtuple
from fractions import Fraction

# Pylint may report no-member error due to C extension
import Levenshtein


def compute_difference(gen_stat, ref_stat):
    if type(gen_stat) in (tuple, list):
        return [gen_stat[i] - ref_stat[i] for i in range(min(len(gen_stat), len(ref_stat)))]
    elif isinstance(gen_stat, dict):
        return dict((i, gen_stat[i] - ref_stat[i]) for i in range(len(gen_stat)))
    elif type(gen_stat) in [float, int]:
        return gen_stat - ref_stat


def compute_match(gen_stat, ref_stat):
    if gen_stat == ref_stat:
        return True
    else:
        return False


def match(function):
    function.match = compute_match
    return function


def difference(function):
    function.difference = compute_difference
    return function


class BaseLanguagePlugin():
    separator = u&#39;\t&#39;
    subseparator = u&#39;|&#39;
    default_fields = [&#39;sequence_length&#39;]

    Sequence = namedtuple(&#39;Sequence&#39;, [&#39;representation&#39;, &#39;frequency&#39;])
    Segment = namedtuple(&#39;Segment&#39;, (&#39;sequence_length&#39;,
                                     &#39;segment_length&#39;, &#39;letters&#39;))
    SegmentH = namedtuple(&#39;Segment&#39;, (&#39;sequence_length&#39;,
                                      &#39;segment_length&#39;, &#39;letters&#39;, &#39;hidden&#39;))

    def transform(self):
        raise NotImplementedError

    def pre_transform(self, input_sequence, frequency=1, language=None):
        syllables = input_sequence.split(&#39;-&#39;)
        representation = []
        for syllable in syllables:
            try:
                segments = self.onsetnucleuscoda(syllable, language)
            except AttributeError:
                segments = (syllable, &#39;&#39;, &#39;&#39;)
            for segment in segments:
                representation.append(
                    (self.Segment(len(syllables), len(segment), segment)))
        representation.insert(0, (self.Segment(len(syllables), 1, &#39;^&#39;)))
        representation.append((self.Segment(len(syllables), 1, &#39;$&#39;)))
        return self.Sequence(tuple(representation), frequency)

    def copy_onc(self, input_sequence, frequency=1):
        representation = []
        syllables = input_sequence.split(u&#39;-&#39;)
        nsyllables = len(syllables)
        for syllable in syllables:
            segments = syllable.split(u&#39;:&#39;)
            for segment in segments:
                representation.append(
                    (self.Segment(nsyllables, len(segment), segment)))
        representation.insert(0, (self.Segment(nsyllables, 1, &#39;^&#39;)))
        representation.append((self.Segment(nsyllables, 1, &#39;$&#39;)))
        return self.Sequence(tuple(representation), frequency)

    def copy_onc_hidden(self, input_sequence, frequency=1):
        representation = []
        sequence, hidden_sequence = input_sequence.split(u&#39;|&#39;)
        syllables = sequence.split(u&#39;-&#39;)
        hidden_syllables = hidden_sequence.split(u&#39;-&#39;)
        nsyllables = len(syllables)
        for i in range(nsyllables):
            segments = syllables[i].split(u&#39;:&#39;)
            hidden_segments = hidden_syllables[i].split(u&#39;:&#39;)
            for j in range(len(segments)):
                representation.append(
                    (self.SegmentH(nsyllables, len(segments[j]), segments[j], hidden_segments[j])))
        representation.insert(0, (self.SegmentH(nsyllables, 1, &#39;^&#39;, &#39;^&#39;)))
        representation.append((self.SegmentH(nsyllables, 1, &#39;$&#39;, &#39;$&#39;)))
        return self.Sequence(tuple(representation), frequency)

    # output modes

    def output_pass(self, sequence):
        return sequence[1::-1]

    def output_plain(self, sequence):
        return u&#39;&#39;.join([segment.letters for segment in sequence[1:-1]])

    def output_syllabic(self, sequence):
        return &#39;-&#39;.join(
            u&#39;&#39;.join(segment.letters for segment in sequence[i - 3: i])
            for i in range(4, len(sequence),
                           3))

    def output_segmental(self, sequence):
        return u&#39;:&#39;.join([segment.letters for segment in sequence[1:-1]])

    def statistic_overlap(self, generator, generated_sequence):
        return sum([generator.reference_sequence[i] == generated_sequence[i]
                    for i in range(1, len(generator.reference_sequence) - 1)])

    def statistic_overlap_ratio(self, generator, generated_sequence):
        return Fraction(
            self.statistic_overlap(generator, generated_sequence),
            len(generator.reference_sequence) - 2)

    @match
    @difference
    def statistic_plain_length(self, generator, generated_sequence):
        return len(self.output_plain(generated_sequence)) - 2

    @match
    def statistic_lexicality(self, generator, generated_sequence):
        candidate = self.output_plain(generated_sequence)
        if candidate in generator.word_lexicon[candidate[0], len(candidate)]:
            return &#34;W&#34;
        else:
            return &#34;N&#34;

    @difference
    def _distance(self, source, target):
        return Levenshtein.distance(source, target)

    def _old(self, source, lexicon, n):
        distances = (distance for neighbor,
                     distance in self._neighbors(source, lexicon, n))
        return sum(distances) / float(n)

    def _neighbors(self, source, lexicon, n):
        neighbors = []
        for target in lexicon:
            neighbors.append((target, Levenshtein.distance(source, target)))
        neighbors.sort(key=lambda x: x[1])
        return neighbors[0:n]

    def _neighbors_at_distance(self, source, lexicon, distance):
        neighbors = []
        for target in lexicon:
            if abs(len(target) - len(source)) &gt; distance:
                pass
            elif Levenshtein.distance(source, target) == 1:
                neighbors.append(target)
        return neighbors

    @match
    @difference
    def statistic_old20(self, generator, generated_sequence):
        return self._old(self.output_plain(generated_sequence), generator.neighbor_lexicon, 20)

    @match
    @difference
    def statistic_ned1(self, generator, generated_sequence):
        return len(self._neighbors_at_distance(
            self.output_plain(generated_sequence),
            generator.neighbor_lexicon, 1))

    @difference
    def statistic_transition_frequencies(self, generator, generated_sequence):
        return generator.bigramchain.get_frequencies(generated_sequence)

    def onsetnucleuscoda(self, orthographic_syllable, lang=None):
        self.oncpattern = lang.oncpattern
        m = self.oncpattern.match(orthographic_syllable)
        try:
            return [m.group(1), m.group(2), m.group(3)]
        except AttributeError as err:
            raise AttributeError(&#39;Input syllable could not be segmented&#39;) from err</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="wuggy.plugins.baselanguageplugin.compute_difference"><code class="name flex">
<span>def <span class="ident">compute_difference</span></span>(<span>gen_stat, ref_stat)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compute_difference(gen_stat, ref_stat):
    if type(gen_stat) in (tuple, list):
        return [gen_stat[i] - ref_stat[i] for i in range(min(len(gen_stat), len(ref_stat)))]
    elif isinstance(gen_stat, dict):
        return dict((i, gen_stat[i] - ref_stat[i]) for i in range(len(gen_stat)))
    elif type(gen_stat) in [float, int]:
        return gen_stat - ref_stat</code></pre>
</details>
</dd>
<dt id="wuggy.plugins.baselanguageplugin.compute_match"><code class="name flex">
<span>def <span class="ident">compute_match</span></span>(<span>gen_stat, ref_stat)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compute_match(gen_stat, ref_stat):
    if gen_stat == ref_stat:
        return True
    else:
        return False</code></pre>
</details>
</dd>
<dt id="wuggy.plugins.baselanguageplugin.difference"><code class="name flex">
<span>def <span class="ident">difference</span></span>(<span>function)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def difference(function):
    function.difference = compute_difference
    return function</code></pre>
</details>
</dd>
<dt id="wuggy.plugins.baselanguageplugin.match"><code class="name flex">
<span>def <span class="ident">match</span></span>(<span>function)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def match(function):
    function.match = compute_match
    return function</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="wuggy.plugins.baselanguageplugin.BaseLanguagePlugin"><code class="flex name class">
<span>class <span class="ident">BaseLanguagePlugin</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BaseLanguagePlugin():
    separator = u&#39;\t&#39;
    subseparator = u&#39;|&#39;
    default_fields = [&#39;sequence_length&#39;]

    Sequence = namedtuple(&#39;Sequence&#39;, [&#39;representation&#39;, &#39;frequency&#39;])
    Segment = namedtuple(&#39;Segment&#39;, (&#39;sequence_length&#39;,
                                     &#39;segment_length&#39;, &#39;letters&#39;))
    SegmentH = namedtuple(&#39;Segment&#39;, (&#39;sequence_length&#39;,
                                      &#39;segment_length&#39;, &#39;letters&#39;, &#39;hidden&#39;))

    def transform(self):
        raise NotImplementedError

    def pre_transform(self, input_sequence, frequency=1, language=None):
        syllables = input_sequence.split(&#39;-&#39;)
        representation = []
        for syllable in syllables:
            try:
                segments = self.onsetnucleuscoda(syllable, language)
            except AttributeError:
                segments = (syllable, &#39;&#39;, &#39;&#39;)
            for segment in segments:
                representation.append(
                    (self.Segment(len(syllables), len(segment), segment)))
        representation.insert(0, (self.Segment(len(syllables), 1, &#39;^&#39;)))
        representation.append((self.Segment(len(syllables), 1, &#39;$&#39;)))
        return self.Sequence(tuple(representation), frequency)

    def copy_onc(self, input_sequence, frequency=1):
        representation = []
        syllables = input_sequence.split(u&#39;-&#39;)
        nsyllables = len(syllables)
        for syllable in syllables:
            segments = syllable.split(u&#39;:&#39;)
            for segment in segments:
                representation.append(
                    (self.Segment(nsyllables, len(segment), segment)))
        representation.insert(0, (self.Segment(nsyllables, 1, &#39;^&#39;)))
        representation.append((self.Segment(nsyllables, 1, &#39;$&#39;)))
        return self.Sequence(tuple(representation), frequency)

    def copy_onc_hidden(self, input_sequence, frequency=1):
        representation = []
        sequence, hidden_sequence = input_sequence.split(u&#39;|&#39;)
        syllables = sequence.split(u&#39;-&#39;)
        hidden_syllables = hidden_sequence.split(u&#39;-&#39;)
        nsyllables = len(syllables)
        for i in range(nsyllables):
            segments = syllables[i].split(u&#39;:&#39;)
            hidden_segments = hidden_syllables[i].split(u&#39;:&#39;)
            for j in range(len(segments)):
                representation.append(
                    (self.SegmentH(nsyllables, len(segments[j]), segments[j], hidden_segments[j])))
        representation.insert(0, (self.SegmentH(nsyllables, 1, &#39;^&#39;, &#39;^&#39;)))
        representation.append((self.SegmentH(nsyllables, 1, &#39;$&#39;, &#39;$&#39;)))
        return self.Sequence(tuple(representation), frequency)

    # output modes

    def output_pass(self, sequence):
        return sequence[1::-1]

    def output_plain(self, sequence):
        return u&#39;&#39;.join([segment.letters for segment in sequence[1:-1]])

    def output_syllabic(self, sequence):
        return &#39;-&#39;.join(
            u&#39;&#39;.join(segment.letters for segment in sequence[i - 3: i])
            for i in range(4, len(sequence),
                           3))

    def output_segmental(self, sequence):
        return u&#39;:&#39;.join([segment.letters for segment in sequence[1:-1]])

    def statistic_overlap(self, generator, generated_sequence):
        return sum([generator.reference_sequence[i] == generated_sequence[i]
                    for i in range(1, len(generator.reference_sequence) - 1)])

    def statistic_overlap_ratio(self, generator, generated_sequence):
        return Fraction(
            self.statistic_overlap(generator, generated_sequence),
            len(generator.reference_sequence) - 2)

    @match
    @difference
    def statistic_plain_length(self, generator, generated_sequence):
        return len(self.output_plain(generated_sequence)) - 2

    @match
    def statistic_lexicality(self, generator, generated_sequence):
        candidate = self.output_plain(generated_sequence)
        if candidate in generator.word_lexicon[candidate[0], len(candidate)]:
            return &#34;W&#34;
        else:
            return &#34;N&#34;

    @difference
    def _distance(self, source, target):
        return Levenshtein.distance(source, target)

    def _old(self, source, lexicon, n):
        distances = (distance for neighbor,
                     distance in self._neighbors(source, lexicon, n))
        return sum(distances) / float(n)

    def _neighbors(self, source, lexicon, n):
        neighbors = []
        for target in lexicon:
            neighbors.append((target, Levenshtein.distance(source, target)))
        neighbors.sort(key=lambda x: x[1])
        return neighbors[0:n]

    def _neighbors_at_distance(self, source, lexicon, distance):
        neighbors = []
        for target in lexicon:
            if abs(len(target) - len(source)) &gt; distance:
                pass
            elif Levenshtein.distance(source, target) == 1:
                neighbors.append(target)
        return neighbors

    @match
    @difference
    def statistic_old20(self, generator, generated_sequence):
        return self._old(self.output_plain(generated_sequence), generator.neighbor_lexicon, 20)

    @match
    @difference
    def statistic_ned1(self, generator, generated_sequence):
        return len(self._neighbors_at_distance(
            self.output_plain(generated_sequence),
            generator.neighbor_lexicon, 1))

    @difference
    def statistic_transition_frequencies(self, generator, generated_sequence):
        return generator.bigramchain.get_frequencies(generated_sequence)

    def onsetnucleuscoda(self, orthographic_syllable, lang=None):
        self.oncpattern = lang.oncpattern
        m = self.oncpattern.match(orthographic_syllable)
        try:
            return [m.group(1), m.group(2), m.group(3)]
        except AttributeError as err:
            raise AttributeError(&#39;Input syllable could not be segmented&#39;) from err</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="wuggy.plugins.baselanguageplugin.BaseLanguagePlugin.Segment"><code class="name">var <span class="ident">Segment</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="wuggy.plugins.baselanguageplugin.BaseLanguagePlugin.SegmentH"><code class="name">var <span class="ident">SegmentH</span></code></dt>
<dd>
<div class="desc"><p>Segment(sequence_length, segment_length, letters, hidden)</p></div>
</dd>
<dt id="wuggy.plugins.baselanguageplugin.BaseLanguagePlugin.Sequence"><code class="name">var <span class="ident">Sequence</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="wuggy.plugins.baselanguageplugin.BaseLanguagePlugin.default_fields"><code class="name">var <span class="ident">default_fields</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="wuggy.plugins.baselanguageplugin.BaseLanguagePlugin.separator"><code class="name">var <span class="ident">separator</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="wuggy.plugins.baselanguageplugin.BaseLanguagePlugin.subseparator"><code class="name">var <span class="ident">subseparator</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="wuggy.plugins.baselanguageplugin.BaseLanguagePlugin.copy_onc"><code class="name flex">
<span>def <span class="ident">copy_onc</span></span>(<span>self, input_sequence, frequency=1)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy_onc(self, input_sequence, frequency=1):
    representation = []
    syllables = input_sequence.split(u&#39;-&#39;)
    nsyllables = len(syllables)
    for syllable in syllables:
        segments = syllable.split(u&#39;:&#39;)
        for segment in segments:
            representation.append(
                (self.Segment(nsyllables, len(segment), segment)))
    representation.insert(0, (self.Segment(nsyllables, 1, &#39;^&#39;)))
    representation.append((self.Segment(nsyllables, 1, &#39;$&#39;)))
    return self.Sequence(tuple(representation), frequency)</code></pre>
</details>
</dd>
<dt id="wuggy.plugins.baselanguageplugin.BaseLanguagePlugin.copy_onc_hidden"><code class="name flex">
<span>def <span class="ident">copy_onc_hidden</span></span>(<span>self, input_sequence, frequency=1)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy_onc_hidden(self, input_sequence, frequency=1):
    representation = []
    sequence, hidden_sequence = input_sequence.split(u&#39;|&#39;)
    syllables = sequence.split(u&#39;-&#39;)
    hidden_syllables = hidden_sequence.split(u&#39;-&#39;)
    nsyllables = len(syllables)
    for i in range(nsyllables):
        segments = syllables[i].split(u&#39;:&#39;)
        hidden_segments = hidden_syllables[i].split(u&#39;:&#39;)
        for j in range(len(segments)):
            representation.append(
                (self.SegmentH(nsyllables, len(segments[j]), segments[j], hidden_segments[j])))
    representation.insert(0, (self.SegmentH(nsyllables, 1, &#39;^&#39;, &#39;^&#39;)))
    representation.append((self.SegmentH(nsyllables, 1, &#39;$&#39;, &#39;$&#39;)))
    return self.Sequence(tuple(representation), frequency)</code></pre>
</details>
</dd>
<dt id="wuggy.plugins.baselanguageplugin.BaseLanguagePlugin.onsetnucleuscoda"><code class="name flex">
<span>def <span class="ident">onsetnucleuscoda</span></span>(<span>self, orthographic_syllable, lang=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def onsetnucleuscoda(self, orthographic_syllable, lang=None):
    self.oncpattern = lang.oncpattern
    m = self.oncpattern.match(orthographic_syllable)
    try:
        return [m.group(1), m.group(2), m.group(3)]
    except AttributeError as err:
        raise AttributeError(&#39;Input syllable could not be segmented&#39;) from err</code></pre>
</details>
</dd>
<dt id="wuggy.plugins.baselanguageplugin.BaseLanguagePlugin.output_pass"><code class="name flex">
<span>def <span class="ident">output_pass</span></span>(<span>self, sequence)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def output_pass(self, sequence):
    return sequence[1::-1]</code></pre>
</details>
</dd>
<dt id="wuggy.plugins.baselanguageplugin.BaseLanguagePlugin.output_plain"><code class="name flex">
<span>def <span class="ident">output_plain</span></span>(<span>self, sequence)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def output_plain(self, sequence):
    return u&#39;&#39;.join([segment.letters for segment in sequence[1:-1]])</code></pre>
</details>
</dd>
<dt id="wuggy.plugins.baselanguageplugin.BaseLanguagePlugin.output_segmental"><code class="name flex">
<span>def <span class="ident">output_segmental</span></span>(<span>self, sequence)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def output_segmental(self, sequence):
    return u&#39;:&#39;.join([segment.letters for segment in sequence[1:-1]])</code></pre>
</details>
</dd>
<dt id="wuggy.plugins.baselanguageplugin.BaseLanguagePlugin.output_syllabic"><code class="name flex">
<span>def <span class="ident">output_syllabic</span></span>(<span>self, sequence)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def output_syllabic(self, sequence):
    return &#39;-&#39;.join(
        u&#39;&#39;.join(segment.letters for segment in sequence[i - 3: i])
        for i in range(4, len(sequence),
                       3))</code></pre>
</details>
</dd>
<dt id="wuggy.plugins.baselanguageplugin.BaseLanguagePlugin.pre_transform"><code class="name flex">
<span>def <span class="ident">pre_transform</span></span>(<span>self, input_sequence, frequency=1, language=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pre_transform(self, input_sequence, frequency=1, language=None):
    syllables = input_sequence.split(&#39;-&#39;)
    representation = []
    for syllable in syllables:
        try:
            segments = self.onsetnucleuscoda(syllable, language)
        except AttributeError:
            segments = (syllable, &#39;&#39;, &#39;&#39;)
        for segment in segments:
            representation.append(
                (self.Segment(len(syllables), len(segment), segment)))
    representation.insert(0, (self.Segment(len(syllables), 1, &#39;^&#39;)))
    representation.append((self.Segment(len(syllables), 1, &#39;$&#39;)))
    return self.Sequence(tuple(representation), frequency)</code></pre>
</details>
</dd>
<dt id="wuggy.plugins.baselanguageplugin.BaseLanguagePlugin.statistic_lexicality"><code class="name flex">
<span>def <span class="ident">statistic_lexicality</span></span>(<span>self, generator, generated_sequence)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@match
def statistic_lexicality(self, generator, generated_sequence):
    candidate = self.output_plain(generated_sequence)
    if candidate in generator.word_lexicon[candidate[0], len(candidate)]:
        return &#34;W&#34;
    else:
        return &#34;N&#34;</code></pre>
</details>
</dd>
<dt id="wuggy.plugins.baselanguageplugin.BaseLanguagePlugin.statistic_ned1"><code class="name flex">
<span>def <span class="ident">statistic_ned1</span></span>(<span>self, generator, generated_sequence)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@match
@difference
def statistic_ned1(self, generator, generated_sequence):
    return len(self._neighbors_at_distance(
        self.output_plain(generated_sequence),
        generator.neighbor_lexicon, 1))</code></pre>
</details>
</dd>
<dt id="wuggy.plugins.baselanguageplugin.BaseLanguagePlugin.statistic_old20"><code class="name flex">
<span>def <span class="ident">statistic_old20</span></span>(<span>self, generator, generated_sequence)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@match
@difference
def statistic_old20(self, generator, generated_sequence):
    return self._old(self.output_plain(generated_sequence), generator.neighbor_lexicon, 20)</code></pre>
</details>
</dd>
<dt id="wuggy.plugins.baselanguageplugin.BaseLanguagePlugin.statistic_overlap"><code class="name flex">
<span>def <span class="ident">statistic_overlap</span></span>(<span>self, generator, generated_sequence)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def statistic_overlap(self, generator, generated_sequence):
    return sum([generator.reference_sequence[i] == generated_sequence[i]
                for i in range(1, len(generator.reference_sequence) - 1)])</code></pre>
</details>
</dd>
<dt id="wuggy.plugins.baselanguageplugin.BaseLanguagePlugin.statistic_overlap_ratio"><code class="name flex">
<span>def <span class="ident">statistic_overlap_ratio</span></span>(<span>self, generator, generated_sequence)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def statistic_overlap_ratio(self, generator, generated_sequence):
    return Fraction(
        self.statistic_overlap(generator, generated_sequence),
        len(generator.reference_sequence) - 2)</code></pre>
</details>
</dd>
<dt id="wuggy.plugins.baselanguageplugin.BaseLanguagePlugin.statistic_plain_length"><code class="name flex">
<span>def <span class="ident">statistic_plain_length</span></span>(<span>self, generator, generated_sequence)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@match
@difference
def statistic_plain_length(self, generator, generated_sequence):
    return len(self.output_plain(generated_sequence)) - 2</code></pre>
</details>
</dd>
<dt id="wuggy.plugins.baselanguageplugin.BaseLanguagePlugin.statistic_transition_frequencies"><code class="name flex">
<span>def <span class="ident">statistic_transition_frequencies</span></span>(<span>self, generator, generated_sequence)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@difference
def statistic_transition_frequencies(self, generator, generated_sequence):
    return generator.bigramchain.get_frequencies(generated_sequence)</code></pre>
</details>
</dd>
<dt id="wuggy.plugins.baselanguageplugin.BaseLanguagePlugin.transform"><code class="name flex">
<span>def <span class="ident">transform</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def transform(self):
    raise NotImplementedError</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<h2><a href="/wuggy">Wuggy Documentation</a></h2>
<a class="homelink" rel="home" title="Wuggy Home" href="https://github.com/Zenulous/wuggy/">
<img src="http://crr.ugent.be/wordpress/wp-content/uploads/2010/04/wug.jpg" alt="Wuggy Logo">
</a>
<h1>Quickstarts</h2>
<h3><a href="/wuggy/generators/wuggygenerator.html#generate-classic-examples" title="generate-pseudowords">Easily generate pseudowords</a></h3>
<h3><a href="/wuggy/plugins/baselanguageplugin.html#creating-a-custom-language-plugin" title="create-language-plugin">Create a custom language plugin</a></h3>
</header>
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#examples">Examples</a><ul>
<li><a href="#creating-a-custom-language-plugin">Creating a custom language plugin</a><ul>
<li><a href="#based-on-an-official-language-plugin">Based on an official language plugin</a></li>
<li><a href="#from-scratch">From scratch</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="wuggy.plugins" href="index.html">wuggy.plugins</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="wuggy.plugins.baselanguageplugin.compute_difference" href="#wuggy.plugins.baselanguageplugin.compute_difference">compute_difference</a></code></li>
<li><code><a title="wuggy.plugins.baselanguageplugin.compute_match" href="#wuggy.plugins.baselanguageplugin.compute_match">compute_match</a></code></li>
<li><code><a title="wuggy.plugins.baselanguageplugin.difference" href="#wuggy.plugins.baselanguageplugin.difference">difference</a></code></li>
<li><code><a title="wuggy.plugins.baselanguageplugin.match" href="#wuggy.plugins.baselanguageplugin.match">match</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="wuggy.plugins.baselanguageplugin.BaseLanguagePlugin" href="#wuggy.plugins.baselanguageplugin.BaseLanguagePlugin">BaseLanguagePlugin</a></code></h4>
<ul class="">
<li><code><a title="wuggy.plugins.baselanguageplugin.BaseLanguagePlugin.Segment" href="#wuggy.plugins.baselanguageplugin.BaseLanguagePlugin.Segment">Segment</a></code></li>
<li><code><a title="wuggy.plugins.baselanguageplugin.BaseLanguagePlugin.SegmentH" href="#wuggy.plugins.baselanguageplugin.BaseLanguagePlugin.SegmentH">SegmentH</a></code></li>
<li><code><a title="wuggy.plugins.baselanguageplugin.BaseLanguagePlugin.Sequence" href="#wuggy.plugins.baselanguageplugin.BaseLanguagePlugin.Sequence">Sequence</a></code></li>
<li><code><a title="wuggy.plugins.baselanguageplugin.BaseLanguagePlugin.copy_onc" href="#wuggy.plugins.baselanguageplugin.BaseLanguagePlugin.copy_onc">copy_onc</a></code></li>
<li><code><a title="wuggy.plugins.baselanguageplugin.BaseLanguagePlugin.copy_onc_hidden" href="#wuggy.plugins.baselanguageplugin.BaseLanguagePlugin.copy_onc_hidden">copy_onc_hidden</a></code></li>
<li><code><a title="wuggy.plugins.baselanguageplugin.BaseLanguagePlugin.default_fields" href="#wuggy.plugins.baselanguageplugin.BaseLanguagePlugin.default_fields">default_fields</a></code></li>
<li><code><a title="wuggy.plugins.baselanguageplugin.BaseLanguagePlugin.onsetnucleuscoda" href="#wuggy.plugins.baselanguageplugin.BaseLanguagePlugin.onsetnucleuscoda">onsetnucleuscoda</a></code></li>
<li><code><a title="wuggy.plugins.baselanguageplugin.BaseLanguagePlugin.output_pass" href="#wuggy.plugins.baselanguageplugin.BaseLanguagePlugin.output_pass">output_pass</a></code></li>
<li><code><a title="wuggy.plugins.baselanguageplugin.BaseLanguagePlugin.output_plain" href="#wuggy.plugins.baselanguageplugin.BaseLanguagePlugin.output_plain">output_plain</a></code></li>
<li><code><a title="wuggy.plugins.baselanguageplugin.BaseLanguagePlugin.output_segmental" href="#wuggy.plugins.baselanguageplugin.BaseLanguagePlugin.output_segmental">output_segmental</a></code></li>
<li><code><a title="wuggy.plugins.baselanguageplugin.BaseLanguagePlugin.output_syllabic" href="#wuggy.plugins.baselanguageplugin.BaseLanguagePlugin.output_syllabic">output_syllabic</a></code></li>
<li><code><a title="wuggy.plugins.baselanguageplugin.BaseLanguagePlugin.pre_transform" href="#wuggy.plugins.baselanguageplugin.BaseLanguagePlugin.pre_transform">pre_transform</a></code></li>
<li><code><a title="wuggy.plugins.baselanguageplugin.BaseLanguagePlugin.separator" href="#wuggy.plugins.baselanguageplugin.BaseLanguagePlugin.separator">separator</a></code></li>
<li><code><a title="wuggy.plugins.baselanguageplugin.BaseLanguagePlugin.statistic_lexicality" href="#wuggy.plugins.baselanguageplugin.BaseLanguagePlugin.statistic_lexicality">statistic_lexicality</a></code></li>
<li><code><a title="wuggy.plugins.baselanguageplugin.BaseLanguagePlugin.statistic_ned1" href="#wuggy.plugins.baselanguageplugin.BaseLanguagePlugin.statistic_ned1">statistic_ned1</a></code></li>
<li><code><a title="wuggy.plugins.baselanguageplugin.BaseLanguagePlugin.statistic_old20" href="#wuggy.plugins.baselanguageplugin.BaseLanguagePlugin.statistic_old20">statistic_old20</a></code></li>
<li><code><a title="wuggy.plugins.baselanguageplugin.BaseLanguagePlugin.statistic_overlap" href="#wuggy.plugins.baselanguageplugin.BaseLanguagePlugin.statistic_overlap">statistic_overlap</a></code></li>
<li><code><a title="wuggy.plugins.baselanguageplugin.BaseLanguagePlugin.statistic_overlap_ratio" href="#wuggy.plugins.baselanguageplugin.BaseLanguagePlugin.statistic_overlap_ratio">statistic_overlap_ratio</a></code></li>
<li><code><a title="wuggy.plugins.baselanguageplugin.BaseLanguagePlugin.statistic_plain_length" href="#wuggy.plugins.baselanguageplugin.BaseLanguagePlugin.statistic_plain_length">statistic_plain_length</a></code></li>
<li><code><a title="wuggy.plugins.baselanguageplugin.BaseLanguagePlugin.statistic_transition_frequencies" href="#wuggy.plugins.baselanguageplugin.BaseLanguagePlugin.statistic_transition_frequencies">statistic_transition_frequencies</a></code></li>
<li><code><a title="wuggy.plugins.baselanguageplugin.BaseLanguagePlugin.subseparator" href="#wuggy.plugins.baselanguageplugin.BaseLanguagePlugin.subseparator">subseparator</a></code></li>
<li><code><a title="wuggy.plugins.baselanguageplugin.BaseLanguagePlugin.transform" href="#wuggy.plugins.baselanguageplugin.BaseLanguagePlugin.transform">transform</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>